#!/usr/bin/env node
/**
 * Extracts pure JavaScript functions from the giil heredoc for testing.
 *
 * This creates a standalone module with ONLY the pure functions that can be
 * tested without playwright/sharp dependencies.
 *
 * Usage:
 *   node extract-functions.mjs > /tmp/giil-pure-functions.mjs
 *   node --test platform-detection.test.mjs
 */

import { readFileSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const giilPath = join(__dirname, '..', '..', 'giil');

// Read the giil script
const giilContent = readFileSync(giilPath, 'utf8');

// Extract the JavaScript heredoc between SCRIPT_EOF markers
const heredocMatch = giilContent.match(/cat > "\$script_path" << 'SCRIPT_EOF'\n([\s\S]*?)\nSCRIPT_EOF/);

if (!heredocMatch) {
    console.error('Failed to extract JavaScript heredoc from giil');
    process.exit(1);
}

const jsCode = heredocMatch[1];

// Extract specific functions/constants we want to test
const extractors = [
    // ExitCodes constant
    { name: 'ExitCodes', pattern: /const ExitCodes = \{[\s\S]*?\};/ },

    // detectPlatform function (parameter is urlStr)
    { name: 'detectPlatform', pattern: /function detectPlatform\(urlStr\) \{[\s\S]*?^\}/m },

    // validateContentType function
    { name: 'validateContentType', pattern: /function validateContentType\(contentType\) \{[\s\S]*?^\}/m },

    // validateMagicBytes function
    { name: 'validateMagicBytes', pattern: /function validateMagicBytes\(buffer\) \{[\s\S]*?^\}/m },

    // validateImageContent function (has default params)
    { name: 'validateImageContent', pattern: /function validateImageContent\(buffer, contentType = null, debugMode = false\) \{[\s\S]*?^\}/m },

    // formatJsonSuccess function (v3 JSON schema)
    { name: 'formatJsonSuccess', pattern: /function formatJsonSuccess\(data\) \{[\s\S]*?^\}/m },

    // formatJsonError function (v3 JSON schema)
    { name: 'formatJsonError', pattern: /function formatJsonError\(code, message, remediation = null\) \{[\s\S]*?^\}/m },

    // errorCodeToExit mapping
    { name: 'errorCodeToExit', pattern: /const errorCodeToExit = \{[\s\S]*?\};/ },

    // extractGooglePhotosBaseUrl function (pure URL manipulation)
    { name: 'extractGooglePhotosBaseUrl', pattern: /function extractGooglePhotosBaseUrl\(cdnUrl\) \{[\s\S]*?^\}/m },

    // extractGoogleDriveFileId function (extract file ID from various URL formats)
    { name: 'extractGoogleDriveFileId', pattern: /function extractGoogleDriveFileId\(urlStr\) \{[\s\S]*?^\}/m },

    // getGoogleDriveDownloadUrl function (construct download URL)
    { name: 'getGoogleDriveDownloadUrl', pattern: /function getGoogleDriveDownloadUrl\(fileId\) \{[\s\S]*?^\}/m },

    // getGoogleDriveViewerUrl function (construct viewer URL)
    { name: 'getGoogleDriveViewerUrl', pattern: /function getGoogleDriveViewerUrl\(fileId\) \{[\s\S]*?^\}/m },

    // formatDateForFilename function (pure date formatting for filenames)
    { name: 'formatDateForFilename', pattern: /function formatDateForFilename\(date\) \{[\s\S]*?^\}/m },

    // formatDateForJson function (pure date formatting for JSON output)
    { name: 'formatDateForJson', pattern: /function formatDateForJson\(date\) \{[\s\S]*?^\}/m },

    // validateGoogleDriveResponse function (pure buffer validation)
    { name: 'validateGoogleDriveResponse', pattern: /function validateGoogleDriveResponse\(buffer\) \{[\s\S]*?^\}/m },

    // getExifDateTime function (async, uses exifr)
    { name: 'getExifDateTime', pattern: /async function getExifDateTime\(buffer\) \{[\s\S]*?^\}/m },
];

// Build the output module - track which functions were extracted
const extractedFunctions = [];
let functionsOutput = '';

for (const { name, pattern } of extractors) {
    const match = jsCode.match(pattern);
    if (match) {
        functionsOutput += `// --- ${name} ---\n`;
        functionsOutput += match[0] + '\n\n';
        extractedFunctions.push(name);
    } else {
        console.error(`Warning: Could not extract ${name}`);
    }
}

// Build header with conditional imports
let output = '';

// Only add exifr import if getExifDateTime was extracted
if (extractedFunctions.includes('getExifDateTime')) {
    output += `import exifr from 'exifr';\n\n`;
}

output += `/**
 * Pure functions extracted from giil for unit testing.
 * Auto-generated by extract-functions.mjs - DO NOT EDIT
 * Generated: ${new Date().toISOString()}
 */

// Mutable platform variable for testing JSON formatting functions
// In production this is set from detectPlatform(url), but tests can set it directly
let currentPlatform = 'unknown';
export function setCurrentPlatform(platform) {
    currentPlatform = platform;
}

`;

output += functionsOutput;

// Add exports (setCurrentPlatform is already exported inline above)
// Only export functions that were actually extracted
if (extractedFunctions.length > 0) {
    output += `// Exports for testing\nexport {\n    ${extractedFunctions.join(',\n    ')}\n};\n`;
}

console.log(output);
